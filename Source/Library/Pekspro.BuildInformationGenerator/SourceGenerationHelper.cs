using System.Text;

namespace Pekspro.BuildInformationGenerator;

public static class SourceGenerationHelper
{
    private const string Header = @"//---------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Pekspro.BuildInformationGenerator source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------
";

    public static string GenerateExtensionClass(in BuildInformationToGenerate buildInfoToGenerate,
        in CompilationInformation compilationInformation, InformationProvider informationProvider)
    {
        StringBuilder sb = new StringBuilder();
        
        AddHeader(sb, buildInfoToGenerate);

        bool added = false;

        added |= AddBuildTime(sb, buildInfoToGenerate, compilationInformation, informationProvider);
        added |= AddGit(sb, buildInfoToGenerate, compilationInformation, informationProvider);
        added |= AddAssemblyVersion(sb, buildInfoToGenerate, compilationInformation, informationProvider);
        added |= AddOSVersion(sb, buildInfoToGenerate, informationProvider);
        added |= AddDotNetVersion(sb, buildInfoToGenerate, informationProvider);
        added |= AddWorkloadInfo(sb, buildInfoToGenerate, informationProvider);

        if (!added)
        {
            AddNothingAddedWarning(sb);
        }

        AddFooter(sb, buildInfoToGenerate);

        return sb.ToString();
    }

    private static bool AddBuildTime(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddBuildTime || buildInfoToGenerate.AddLocalBuildTime)
        {
            var valueSource = informationProvider.GetBuildTime(buildInfoToGenerate, compilationInformation);

            if (buildInfoToGenerate.AddBuildTime)
            {
                DateTime utcTime = valueSource.Value.UtcDateTime;

                sb.Append(@"

        /// <summary>
        /// Build time: ").Append(utcTime.ToString("yyyy-MM-dd HH:mm:ss")).Append(@"
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public static readonly global::System.DateTime BuildTime = new global::System.DateTime(")
                .Append(utcTime.Ticks)
                .Append("L, global::System.DateTimeKind.Utc);");
            }

            if (buildInfoToGenerate.AddLocalBuildTime)
            {
                sb.Append(@"

        /// <summary>
        /// Local build time: ").Append(valueSource.Value.ToString("yyyy-MM-dd HH:mm:ss (zzz)")).Append(@"
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public static readonly global::System.DateTimeOffset LocalBuildTime = new global::System.DateTimeOffset(")
                .Append(valueSource.Value.Ticks)
                .Append("L, new global::System.TimeSpan(").Append(valueSource.Value.Offset.Ticks).Append(@"));");
            }

            return true;
        }

        return false;
    }

    private static bool AddGit(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation, InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddGitCommitId || buildInfoToGenerate.AddGitBranch)
        {
            sb.Append(@"

        /// <summary>
        /// Build information related to git.
        /// </summary>
        static public partial class Git
        {");

            AddGitCommitId(sb, buildInfoToGenerate, compilationInformation, informationProvider);
            AddGitBranch(sb, buildInfoToGenerate, informationProvider);

            sb.Append(@"

        }");

            return true;
        }

        return false;
    }

    private static bool AddGitCommitId(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation,InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddGitCommitId)
        {
            string commitId = "", source = "";

            try
            {
                (commitId, source) = informationProvider.GetGitCommitId(buildInfoToGenerate, compilationInformation);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the git commit id: ").Append(ex.Message);
            }

            string shortCommitId = commitId.Length >= 8 ? commitId.Substring(0, 8) : commitId;

            sb.Append(@"

            /// <summary>
            /// The commit id in git at the time of build.
            /// ").Append(source).Append(@"
            /// </summary>
            public const string CommitId = ").AppendAndQouteAndFormatLiteral(commitId).Append(@";

            /// <summary>
            /// The short commit id in git at the time of build.
            /// ").Append(source).Append(@"
            /// </summary>
            public const string ShortCommitId = ").AppendAndQouteAndFormatLiteral(shortCommitId).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddGitBranch(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddGitBranch)
        {
            string branch = "";
            string source = "";

            try
            {
                (branch, source) = informationProvider.GetGitBranch(buildInfoToGenerate);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the git branch: ").Append(ex.Message);
            }

            sb.Append(@"

            /// <summary>
            /// The git branch used at build time.
            /// ").Append(source).Append(@"
            /// </summary>
            public const string Branch = ").AppendAndQouteAndFormatLiteral(branch).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddAssemblyVersion(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddAssemblyVersion)
        {
            var valueSource = informationProvider.GetAssemblyVersion(buildInfoToGenerate, compilationInformation);
            
            sb.Append(@"

        /// <summary>
        /// Version of the assembly.
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public const string AssemblyVersionString = ").AppendAndQouteAndFormatLiteral(valueSource.Value).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddOSVersion(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddOSVersion)
        {
            var valueSource = informationProvider.GetOSVersion(buildInfoToGenerate);

            sb.Append(@"

        /// <summary>
        /// OS version of the building machine.
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public const string OSVersion = ").AppendAndQouteAndFormatLiteral(valueSource.Value).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddDotNetVersion(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddDotNetSdkVersion)
        {
            string version = "", source = "";

            try
            {
                (version, source) = informationProvider.GetDotNetVersion(buildInfoToGenerate);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the .NET SDK version: ").Append(ex.Message);
            }

            sb.Append(@"

        /// <summary>
        /// .NET SDK version used at build time.
        /// ").Append(source).Append(@"
        /// </summary>
        public const string DotNetSdkVersion = ").AppendAndQouteAndFormatLiteral(version).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddWorkloadInfo(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddWorkloadMauiVersion || buildInfoToGenerate.AddWorkloadWasmToolsVersion)
        {
            sb.Append(@"

        /// <summary>
        /// Build information related to .NET Workloads.
        /// </summary>
        static public partial class Workloads
        {");


            string workLoadList = "";

            try
            {
                workLoadList = informationProvider.GetWorkloadList(buildInfoToGenerate);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the MAUI workloads: ").Append(ex.Message);
            }

            if (buildInfoToGenerate.AddWorkloadMauiVersion)
            {
                var maui = informationProvider.GetMauiVersion(buildInfoToGenerate, workLoadList);

                sb.Append(@"

            /// <summary>
            /// MAUI version used at build time.
            /// ").Append(maui.Source).Append(@"
            /// </summary>
            public const string MauiVersion = ").AppendAndQouteAndFormatLiteral(maui.Value).Append(@";");
            }

            if (buildInfoToGenerate.AddWorkloadWasmToolsVersion)
            {
                var wasmTools = informationProvider.GetWasmToolsVersion(buildInfoToGenerate, workLoadList);

                sb.Append(@"

            /// <summary>
            /// wasm-tools version used at build time.
            /// ").Append(wasmTools.Source).Append(@"
            /// </summary>
            public const string WasmToolsVersion = ").AppendAndQouteAndFormatLiteral(wasmTools.Value).Append(@";");
            }

            sb.Append(@"

        }");

            return true;
        }

        return false;
    }

    private static void AddNothingAddedWarning(StringBuilder sb)
    { 
        sb.Append(@"

#warning No build information is added. Please define which information to be added like this: [BuildInformation(AddBuildTime = true, AddGitCommitId = true)]");
    }

    private static void AddHeader(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate)
    {
        sb.Append(Header);

        if (!string.IsNullOrEmpty(buildInfoToGenerate.Namespace))
        {
            sb.Append(@"
namespace ").Append(buildInfoToGenerate.Namespace).Append(@"
{");
        }

        sb.Append(@"
    /// <summary>
    /// Build information.").Append(buildInfoToGenerate.Fake ? " Note! Faked values are used. You can control this with the properties FakeIfDebug and FakeIfRelease.": "").Append(@"
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Pekspro.BuildInformationGenerator"", """).Append(Constants.Version).Append(@""")]
    ").Append(@"static partial class ").Append(buildInfoToGenerate.Name).Append(@"
    {");
    }

    private static void AddFooter(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate)
    {
        sb.Append(@"

    }");

        if (!string.IsNullOrEmpty(buildInfoToGenerate.Namespace))
        {
            sb.Append(@"
}");
        }
    }
}
