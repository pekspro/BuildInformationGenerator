using System.Text;

namespace Pekspro.BuildInformationGenerator;

public static class SourceGenerationHelper
{
    private const string Header = @"//---------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Pekspro.BuildInformationGenerator source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------
";

    public static string GenerateExtensionClass(in BuildInformationToGenerate buildInfoToGenerate,
        in CompilationInformation compilationInformation, InformationProvider informationProvider)
    {
        StringBuilder sb = new StringBuilder();
        
        AddHeader(sb, buildInfoToGenerate);

        bool added = false;

        added |= AddBuildTime(sb, buildInfoToGenerate, compilationInformation, informationProvider);
        added |= AddGitCommitId(sb, buildInfoToGenerate, compilationInformation, informationProvider);
        added |= AddGitBranch(sb, buildInfoToGenerate, informationProvider);
        added |= AddAssemblyVersion(sb, buildInfoToGenerate, compilationInformation, informationProvider);
        added |= AddOSVersion(sb, buildInfoToGenerate, informationProvider);
        added |= AddDotNetVersion(sb, buildInfoToGenerate, informationProvider);
        added |= AddWorkloadInfo(sb, buildInfoToGenerate, informationProvider);

        if (!added)
        {
            AddNothingAddedWarning(sb);
        }

        AddFooter(sb, buildInfoToGenerate);

        return sb.ToString();
    }

    private static bool AddBuildTime(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddBuildTime || buildInfoToGenerate.AddLocalBuildTime)
        {
            var valueSource = informationProvider.GetBuildTime(buildInfoToGenerate, compilationInformation);

            if (buildInfoToGenerate.AddBuildTime)
            {
                DateTime utcTime = valueSource.Value.UtcDateTime;

                sb.Append(@"

        /// <summary>
        /// Build time: ").Append(utcTime.ToString("yyyy-MM-dd HH:mm:ss")).Append(@"
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public static readonly global::System.DateTime BuildTime = new global::System.DateTime(")
                .Append(utcTime.Ticks)
                .Append("L, global::System.DateTimeKind.Utc);");
            }

            if (buildInfoToGenerate.AddLocalBuildTime)
            {
                sb.Append(@"

        /// <summary>
        /// Local build time: ").Append(valueSource.Value.ToString("yyyy-MM-dd HH:mm:ss (zzz)")).Append(@"
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public static readonly global::System.DateTimeOffset LocalBuildTime = new global::System.DateTimeOffset(")
                .Append(valueSource.Value.Ticks)
                .Append("L, new global::System.TimeSpan(").Append(valueSource.Value.Offset.Ticks).Append(@"));");
            }

            return true;
        }

        return false;
    }

    private static bool AddGitCommitId(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation,InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddGitCommitId)
        {
            string commitId = "", shortCommitId = "", source = "";

            try
            {
                (commitId, source) = informationProvider.GetGitCommitId(buildInfoToGenerate, compilationInformation);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the git commit id: ").Append(ex.Message);
            }

            shortCommitId = commitId.Length >= 8 ? commitId.Substring(0, 8) : commitId;

            sb.Append(@"

        /// <summary>
        /// The commit id in git at the time of build.
        /// ").Append(source).Append(@"
        /// </summary>
        public const string GitCommitId = ").AppendAndQouteAndFormatLiteral(commitId).Append(@";

        /// <summary>
        /// The short commit id in git at the time of build.
        /// ").Append(source).Append(@"
        /// </summary>
        public const string GitShortCommitId = ").AppendAndQouteAndFormatLiteral(shortCommitId).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddGitBranch(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddGitBranch)
        {
            string branch = "";
            string source = "";

            try
            {
                (branch, source) = informationProvider.GetGitBranch(buildInfoToGenerate);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the git branch: ").Append(ex.Message);
            }

            sb.Append(@"

        /// <summary>
        /// The git branch used at build time.
        /// ").Append(source).Append(@"
        /// </summary>
        public const string GitBranch = ").AppendAndQouteAndFormatLiteral(branch).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddAssemblyVersion(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in CompilationInformation compilationInformation, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddAssemblyVersion)
        {
            var valueSource = informationProvider.GetAssemblyVersion(buildInfoToGenerate, compilationInformation);
            
            sb.Append(@"

        /// <summary>
        /// Version of the assembly.
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public const string AssemblyVersionString = ").AppendAndQouteAndFormatLiteral(valueSource.Value).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddOSVersion(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddOSVersion)
        {
            var valueSource = informationProvider.GetOSVersion(buildInfoToGenerate);

            sb.Append(@"

        /// <summary>
        /// OS version of the building machine.
        /// ").Append(valueSource.Source).Append(@"
        /// </summary>
        public const string OSVersion = ").AppendAndQouteAndFormatLiteral(valueSource.Value).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddDotNetVersion(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddDotNetSdkVersion)
        {
            string version = "", source = "";

            try
            {
                (version, source) = informationProvider.GetDotNetVersion(buildInfoToGenerate);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the .NET SDK version: ").Append(ex.Message);
            }

            sb.Append(@"

        /// <summary>
        /// .NET SDK version used at build time.
        /// ").Append(source).Append(@"
        /// </summary>
        public const string DotNetSdkVersion = ").AppendAndQouteAndFormatLiteral(version).Append(@";");

            return true;
        }

        return false;
    }

    private static bool AddWorkloadInfo(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate, in InformationProvider informationProvider)
    {
        if (buildInfoToGenerate.AddWorkloadMaui || buildInfoToGenerate.AddWorkloadWasmTools)
        {
            string workLoadList = "";

            try
            {
                workLoadList = informationProvider.GetWorkloadList(buildInfoToGenerate);
            }
            catch (Exception ex)
            {
                sb.Append(@"

#warning An error occurred while getting the MAUI workloads: ").Append(ex.Message);
            }

            if (buildInfoToGenerate.AddWorkloadMaui)
            {
                var maui = informationProvider.GetMauiVersion(buildInfoToGenerate, workLoadList);

                sb.Append(@"

        /// <summary>
        /// Workload MAUI version used at build time.
        /// ").Append(maui.Source).Append(@"
        /// </summary>
        public const string WorkloadMauiVersion = ").AppendAndQouteAndFormatLiteral(maui.Value).Append(@";");
            }

            if (buildInfoToGenerate.AddWorkloadWasmTools)
            {
                var wasmTools = informationProvider.GetWasmToolsVersion(buildInfoToGenerate, workLoadList);

                sb.Append(@"

        /// <summary>
        /// Workload wasm-tools version used at build time.
        /// ").Append(wasmTools.Source).Append(@"
        /// </summary>
        public const string WorkloadWasmToolsVersion = ").AppendAndQouteAndFormatLiteral(wasmTools.Value).Append(@";");
            }

            return true;
        }

        return false;
    }

    private static void AddNothingAddedWarning(StringBuilder sb)
    { 
        sb.Append(@"

#warning No build information is added. Please define which information to be added like this: [BuildInformation(AddBuildTime = true, AddGitCommit = true)]");
    }

    private static void AddHeader(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate)
    {
        sb.Append(Header);

        if (!string.IsNullOrEmpty(buildInfoToGenerate.Namespace))
        {
            sb.Append(@"
namespace ").Append(buildInfoToGenerate.Namespace).Append(@"
{");
        }

        sb.Append(@"
    /// <summary>
    /// Build information.").Append(buildInfoToGenerate.Fake ? " Note! Faked values are used. You can control this with the properties FakeIfDebug and FakeIfRelease.": "").Append(@"
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Pekspro.BuildInformationGenerator"", """).Append(Constants.Version).Append(@""")]
    ").Append(@"static partial class ").Append(buildInfoToGenerate.Name).Append(@"
    {");
    }

    private static void AddFooter(StringBuilder sb, in BuildInformationToGenerate buildInfoToGenerate)
    {
        sb.Append(@"

    }");

        if (!string.IsNullOrEmpty(buildInfoToGenerate.Namespace))
        {
            sb.Append(@"
}");
        }
    }
}
